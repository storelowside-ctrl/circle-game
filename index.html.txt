<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw a Perfect Circle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: white;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        .controls {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        
        button {
            padding: 10px 16px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background 0.2s;
        }
        
        button:hover {
            background: #f5f5f5;
        }
        
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 5;
        }
        
        .instructions h1 {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 16px;
        }
        
        .instructions p {
            font-size: 18px;
            color: #666;
        }
        
        .tryAgain {
            position: absolute;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        
        .tryAgain button {
            padding: 12px 24px;
            background: black;
            color: white;
            border: none;
            font-size: 16px;
        }
        
        .tryAgain button:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        
        <div class="controls">
            <button id="clearBtn">Clear</button>
            <button id="gridBtn">Hide Grid</button>
        </div>
        
        <div class="instructions" id="instructions">
            <h1>Draw a Perfect Circle</h1>
            <p>Click and drag to draw your circle</p>
            <p style="font-size: 14px; color: #999; margin-top: 8px;">
                Best: <span id="bestScore">0</span> | Attempts: <span id="attempts">0</span>
            </p>
        </div>
        
        <div class="tryAgain" id="tryAgain" style="display: none;">
            <button id="tryAgainBtn">Try Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const gridBtn = document.getElementById('gridBtn');
        const tryAgainBtn = document.getElementById('tryAgainBtn');
        const instructions = document.getElementById('instructions');
        const tryAgainDiv = document.getElementById('tryAgain');
        
        let isDrawing = false;
        let points = [];
        let showGrid = true;
        let result = null;
        let bestScore = 0;
        let attempts = 0;
        
        // Set canvas size
        function resizeCanvas() {
            const scale = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * scale;
            canvas.height = window.innerHeight * scale;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(scale, scale);
            drawCanvas();
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Get position from event
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        // Drawing functions
        function drawCanvas() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);
            
            // Draw grid
            if (showGrid) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                const gridSize = 40;
                
                for (let x = 0; x < w; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                for (let y = 0; y < h; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Draw points
            if (points.length > 1) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.stroke();
            }
            
            // Draw result
            if (result) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(0, 0, w, h);
                
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 64px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(`${result.score}/100`, w / 2, h / 2 - 50);
                
                ctx.font = '24px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillText(result.message, w / 2, h / 2 + 30);
                
                ctx.font = '18px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillText(`Best: ${bestScore} | Attempts: ${attempts}`, w / 2, h / 2 + 70);
            }
        }
        
        // Evaluate circle
        function evaluateCircle(points) {
            if (points.length < 10) {
                return { score: 0, message: 'Draw a complete circle!' };
            }
            
            const center = points.reduce((acc, p) => ({
                x: acc.x + p.x,
                y: acc.y + p.y
            }), { x: 0, y: 0 });
            
            center.x /= points.length;
            center.y /= points.length;
            
            let avgRadius = 0;
            for (const p of points) {
                avgRadius += Math.sqrt(Math.pow(p.x - center.x, 2) + Math.pow(p.y - center.y, 2));
            }
            avgRadius /= points.length;
            
            let radiusVariance = 0;
            for (const p of points) {
                const dist = Math.sqrt(Math.pow(p.x - center.x, 2) + Math.pow(p.y - center.y, 2));
                radiusVariance += Math.pow(dist - avgRadius, 2);
            }
            radiusVariance = Math.sqrt(radiusVariance / points.length);
            
            const startPoint = points[0];
            const endPoint = points[points.length - 1];
            const closureDistance = Math.sqrt(
                Math.pow(endPoint.x - startPoint.x, 2) + 
                Math.pow(endPoint.y - startPoint.y, 2)
            );
            
            const isClosed = closureDistance < avgRadius * 0.2;
            
            const maxVariance = avgRadius * 0.5;
            const varianceScore = Math.max(0, 1 - (radiusVariance / maxVariance));
            const closureScore = isClosed ? 1 : 0.5;
            
            let totalScore = Math.round((varianceScore * 0.6 + closureScore * 0.4) * 100);
            totalScore = Math.max(0, Math.min(100, totalScore));
            
            let message;
            if (totalScore >= 95) message = 'Perfect circle! You\'re a true artist! âœ¨';
            else if (totalScore >= 85) message = 'Excellent! Almost perfect! ðŸŽ¯';
            else if (totalScore >= 75) message = 'Great job! Very circular! ðŸ‘';
            else if (totalScore >= 60) message = 'Good effort! Keep practicing! ðŸ’ª';
            else if (totalScore >= 40) message = 'Not bad! Try drawing slower? ðŸ–Šï¸';
            else if (totalScore >= 20) message = 'Give it another shot! ðŸ”„';
            else message = 'Hmm, that looks like abstract art! ðŸŽ¨';
            
            return { score: totalScore, message };
        }
        
        // Event handlers
        function startDrawing(e) {
            e.preventDefault();
            if (result) return;
            
            isDrawing = true;
            points = [getPos(e)];
            result = null;
            instructions.style.display = 'none';
            tryAgainDiv.style.display = 'none';
            drawCanvas();
        }
        
        function draw(e) {
            e.preventDefault();
            if (!isDrawing || result) return;
            
            points.push(getPos(e));
            drawCanvas();
        }
        
        function stopDrawing(e) {
            e.preventDefault();
            if (!isDrawing || result) return;
            
            isDrawing = false;
            result = evaluateCircle(points);
            attempts++;
            
            if (result.score > bestScore) {
                bestScore = result.score;
            }
            
            document.getElementById('bestScore').textContent = bestScore;
            document.getElementById('attempts').textContent = attempts;
            
            tryAgainDiv.style.display = 'block';
            drawCanvas();
        }
        
        function clear() {
            points = [];
            result = null;
            instructions.style.display = 'block';
            tryAgainDiv.style.display = 'none';
            drawCanvas();
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        
        // Touch events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        
        // Button events
        clearBtn.addEventListener('click', clear);
        tryAgainBtn.addEventListener('click', clear);
        
        gridBtn.addEventListener('click', () => {
            showGrid = !showGrid;
            gridBtn.textContent = showGrid ? 'Hide Grid' : 'Show Grid';
            drawCanvas();
        });
        
        // Prevent scrolling on touch devices
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
